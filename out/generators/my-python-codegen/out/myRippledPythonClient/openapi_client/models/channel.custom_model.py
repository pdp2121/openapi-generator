# coding: utf-8

"""
    XRP Ledger Public API

    A JSON RPC API used to query rippled.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictInt, StrictStr
from typing import Any, ClassVar, Dict, List, Optional
from typing import Optional, Set
from typing_extensions import Self

class Channel(BaseModel):
    """
    Channel
    """ # noqa: E501
    account: StrictStr = Field(description="The owner of the channel, as an Address.")
    amount: StrictStr = Field(description="The total amount of XRP, in drops allocated to this channel.")
    balance: StrictStr = Field(description="The total amount of XRP, in drops, paid out from this channel, as of the ledger version used. (You can calculate the amount of XRP left in the channel by subtracting balance from amount.) ")
    cancel_after: Optional[StrictInt] = Field(default=None, description="Time, in seconds since the Ripple Epoch, of this channel's immutable expiration, if one was specified at channel creation. If this is before the close time of the most recent validated ledger, the channel is expired. ")
    channel_id: StrictStr = Field(description="A unique ID for this channel, as a 64-character hexadecimal string. This is also the ID of the channel object in the ledger's state data. ")
    destination_account: StrictStr = Field(description="The destination account of the channel, as an Address. Only this account can receive the XRP in the channel while it is open.")
    destination_tag: Optional[StrictInt] = Field(default=None, description="A 32-bit unsigned integer to use as a destination tag for payments through this channel, if one was specified at channel creation. This indicates the payment channel's beneficiary or other purpose at the destination account. ")
    expiration: Optional[StrictInt] = Field(default=None, description="Time, in seconds since the Ripple Epoch, when this channel is set to expire. This expiration date is mutable. If this is before the close time of the most recent validated ledger, the channel is expired. ")
    public_key: Optional[StrictStr] = Field(default=None, description="The public key for the payment channel in the XRP Ledger's base58 format. Signed claims against this channel must be redeemed with the matching key pair. ")
    public_key_hex: Optional[StrictStr] = Field(default=None, description="The public key for the payment channel in hexadecimal format, if one was specified at channel creation. Signed claims against this channel must be redeemed with the matching key pair. ")
    settle_delay: StrictInt = Field(description="The number of seconds the payment channel must stay open after the owner of the channel requests to close it. ")
    source_tag: Optional[StrictInt] = Field(default=None, description="A 32-bit unsigned integer to use as a source tag for payments through this payment channel, if one was specified at channel creation. This indicates the payment channel's originator or other purpose at the source account. ")
    __properties: ClassVar[List[str]] = ["account", "amount", "balance", "cancel_after", "channel_id", "destination_account", "destination_tag", "expiration", "public_key", "public_key_hex", "settle_delay", "source_tag"]

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of Channel from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of Channel from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "account": obj.get("account"),
            "amount": obj.get("amount"),
            "balance": obj.get("balance"),
            "cancel_after": obj.get("cancel_after"),
            "channel_id": obj.get("channel_id"),
            "destination_account": obj.get("destination_account"),
            "destination_tag": obj.get("destination_tag"),
            "expiration": obj.get("expiration"),
            "public_key": obj.get("public_key"),
            "public_key_hex": obj.get("public_key_hex"),
            "settle_delay": obj.get("settle_delay"),
            "source_tag": obj.get("source_tag")
        })
        return _obj


