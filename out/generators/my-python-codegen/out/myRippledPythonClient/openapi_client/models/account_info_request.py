# coding: utf-8

"""
    XRP Ledger Public API

    A JSON RPC API used to query rippled.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from openapi_client.models.lookup_by_ledger_request_ledger_index import LookupByLedgerRequestLedgerIndex
from typing import Optional, Set
from typing_extensions import Self

class AccountInfoRequest(BaseModel):
    """
    The account_info command retrieves information about an account, its activity, and its XRP balance. All information retrieved is relative to a particular version of the ledger. Returns an AccountInfoResponse 
    """ # noqa: E501
    method: str = "account_info"
    method: StrictStr
    account: StrictStr = Field(description="The account to look up.")
    queue: Optional[StrictBool] = Field(default=None, description="If true, return stats about queued transactions sent by this account. Can only be used when querying for the data from the current open ledger. Not available from servers in Reporting Mode.")
    signer_lists: Optional[StrictBool] = Field(default=None, description="API v1: If true, return any SignerList objects associated with this account. API v2: Identical to v1, but also returns an invalidParams error if you provide a non-boolean value. ")
    ledger_hash: Optional[StrictStr] = Field(default=None, description="A 20-byte hex string for the ledger version to use.")
    ledger_index: Optional[LookupByLedgerRequestLedgerIndex] = None
    api_version: Optional[StrictInt] = Field(default=None, description="The API version to use. If omitted, uses version 1.")
    __properties: ClassVar[List[str]] = ["ledger_hash", "ledger_index", "api_version"]

    @field_validator('method')
    def method_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['account_info']):
            raise ValueError("must be one of enum values ('account_info')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AccountInfoRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        def camel_to_snake(name):
            return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # Convert keys to snake case
        _dict_snake_case = {camel_to_snake(key): value for key, value in _dict.items()}
        
        # override the default output from pydantic by calling `to_dict()` of ledger_index
        if self.ledger_index:
            _dict_snake_case['ledger_index'] = self.ledger_index.to_dict()
        
        return _dict_snake_case

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AccountInfoRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "ledger_hash": obj.get("ledger_hash"),
            "ledger_index": LookupByLedgerRequestLedgerIndex.from_dict(obj["ledger_index"]) if obj.get("ledger_index") is not None else None,
            "api_version": obj.get("api_version")
        })
        return _obj


