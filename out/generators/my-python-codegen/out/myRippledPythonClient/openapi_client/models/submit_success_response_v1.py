# coding: utf-8

"""
    XRP Ledger Public API

    A JSON RPC API used to query rippled.

    The version of the OpenAPI document: 1.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional, Union
from openapi_client.models.response_warning import ResponseWarning
from typing import Optional, Set
from typing_extensions import Self

class SubmitSuccessResponseV1(BaseModel):
    """
    SubmitSuccessResponseV1
    """ # noqa: E501
    tx_json: Optional[Any] = None
    forwarded: Optional[StrictBool] = Field(default=None, description="Indicates whether the request was forwarded.")
    status: StrictStr = Field(description="The status of the response (e.g., 'success').")
    warning: Optional[StrictStr] = Field(default=None, description="A specific warning type (e.g., 'load').")
    warnings: Optional[List[ResponseWarning]] = Field(default=None, description="An array of response warnings.")
    engine_result: Optional[StrictStr] = Field(default=None, description="Text result code indicating the preliminary result of the transaction, for example tesSUCCESS")
    engine_result_code: Optional[StrictInt] = Field(default=None, description="Numeric version of the result code. Not recommended.")
    engine_result_message: Optional[StrictStr] = Field(default=None, description="Human-readable explanation of the transaction's preliminary result")
    tx_blob: Optional[StrictStr] = Field(default=None, description="The complete transaction in hex string format")
    accepted: Optional[StrictBool] = Field(default=None, description="(Omitted in sign-and-submit mode) The value true indicates that the transaction was applied, queued, broadcast, or kept for later. The value false indicates that none of those happened, so the transaction cannot possibly succeed as long as you do not submit it again and have not already submitted it another time. ")
    account_sequence_available: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="(Omitted in sign-and-submit mode) The next Sequence Number available for the sending account after all pending and queued transactions. ")
    account_sequence_next: Optional[Union[StrictFloat, StrictInt]] = Field(default=None, description="(Omitted in sign-and-submit mode) The next Sequence Number for the sending account after all transactions that have been provisionally applied, but not transactions in the queue. ")
    applied: Optional[StrictBool] = Field(default=None, description="(Omitted in sign-and-submit mode) The value true indicates that this transaction was applied to the open ledger. In this case, the transaction is likely, but not guaranteed, to be validated in the next ledger version. ")
    broadcast: Optional[StrictBool] = Field(default=None, description="(Omitted in sign-and-submit mode) The value true indicates this transaction was broadcast to peer servers in the peer-to-peer XRP Ledger network. (Note: if the server has no peers, such as in stand-alone mode, the server uses the value true for cases where it would have broadcast the transaction.) The value false indicates the transaction was not broadcast to any other servers. ")
    kept: Optional[StrictBool] = Field(default=None, description="(Omitted in sign-and-submit mode) The value true indicates that the transaction was kept to be retried later. ")
    queued: Optional[StrictBool] = Field(default=None, description="(Omitted in sign-and-submit mode) The value true indicates the transaction was put in the Transaction Queue, which means it is likely to be included in a future ledger version. ")
    open_ledger_cost: Optional[StrictStr] = Field(default=None, description="(Omitted in sign-and-submit mode) The current open ledger cost before processing this transaction. Transactions with a lower cost are likely to be queued. ")
    validated_ledger_index: Optional[StrictInt] = Field(default=None, description="(Omitted in sign-and-submit mode) The ledger index of the newest validated ledger at the time of submission. This provides a lower bound on the ledger versions that the transaction can appear in as a result of this request. (The transaction could only have been validated in this ledger version or earlier if it had already been submitted before.) ")
    __properties: ClassVar[List[str]] = ["forwarded", "status", "warning", "warnings", "engine_result", "engine_result_code", "engine_result_message", "tx_blob", "accepted", "account_sequence_available", "account_sequence_next", "applied", "broadcast", "kept", "queued", "open_ledger_cost", "validated_ledger_index"]

    @field_validator('status')
    def status_validate_enum(cls, value):
        """Validates the enum"""
        if value not in set(['success']):
            raise ValueError("must be one of enum values ('success')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SubmitSuccessResponseV1 from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        def camel_to_snake(name):
            return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # Convert keys to snake case
        _dict_snake_case = {camel_to_snake(key): value for key, value in _dict.items()}
        
        # override the default output from pydantic by calling `to_dict()` of each item in warnings (list)
        _items = []
        if self.warnings:
            for _item in self.warnings:
                if _item:
                    _items.append(_item.to_dict())
            _dict_snake_case['warnings'] = _items
        
        return _dict_snake_case

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SubmitSuccessResponseV1 from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "forwarded": obj.get("forwarded"),
            "status": obj.get("status"),
            "warning": obj.get("warning"),
            "warnings": [ResponseWarning.from_dict(_item) for _item in obj["warnings"]] if obj.get("warnings") is not None else None,
            "engine_result": obj.get("engine_result"),
            "engine_result_code": obj.get("engine_result_code"),
            "engine_result_message": obj.get("engine_result_message"),
            "tx_blob": obj.get("tx_blob"),
            "accepted": obj.get("accepted"),
            "account_sequence_available": obj.get("account_sequence_available"),
            "account_sequence_next": obj.get("account_sequence_next"),
            "applied": obj.get("applied"),
            "broadcast": obj.get("broadcast"),
            "kept": obj.get("kept"),
            "queued": obj.get("queued"),
            "open_ledger_cost": obj.get("open_ledger_cost"),
            "validated_ledger_index": obj.get("validated_ledger_index")
        })
        return _obj


